import os
import ast
import json
import datetime
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parents[1]
MODULE_DIR = BASE_DIR / "modules"
HISTORY_DIR = BASE_DIR / "history"
HISTORY_DIR.mkdir(exist_ok=True)
(MODULE_DIR / "autogenerated").mkdir(exist_ok=True)

LOG_FILE = HISTORY_DIR / "edit_log.jsonl"

def write_module(path: str, code: str) -> dict:
    """
    Fully autonomous code writer.
    - Creates or updates Python modules.
    - Automatically backs up previous versions.
    - Validates syntax before writing.
    - Logs all changes for audit.
    """

    # Sanity: only allow writes inside /modules
    full_path = MODULE_DIR / path
    if not str(full_path).startswith(str(MODULE_DIR)):
        return {"error": "Invalid path. Bot can only write inside /modules."}

    # Validate syntax
    try:
        ast.parse(code)
    except SyntaxError as e:
        return {"error": f"Syntax error: {e}"}

    # Backup old version if exists
    if full_path.exists():
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = HISTORY_DIR / f"{full_path.name}.bak_{timestamp}"
        backup_path.write_text(full_path.read_text())

    # Write new file
    full_path.write_text(code)

    # Log change
    log_entry = {
        "timestamp": datetime.datetime.now().isoformat(),
        "file": str(full_path),
        "code": code,
    }
    with LOG_FILE.open("a") as f:
        f.write(json.dumps(log_entry) + "\n")

    return {"status": "success", "path": str(full_path)}
